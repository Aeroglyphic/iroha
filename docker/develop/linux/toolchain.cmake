set(CMAKE_SYSTEM_NAME Linux)
IF(NOT DEFINED ENV{CROSS_TRIPLE_PREFIX})
  set(CROSS_TRIPLE_PREFIX arm-linux-gnueabihf)
ELSE()
  set(CROSS_TRIPLE_PREFIX $ENV{CROSS_TRIPLE_PREFIX})
ENDIF()

IF(NOT DEFINED ENV{GCC_VERSION})
  set(GCC_VERSION 5)
ELSE()
  set(GCC_VERSION $ENV{GCC_VERSION})
ENDIF()

IF(NOT DEFINED ENV{TARGET_ARCH})
  set(TARGET_ARCH armhf)
ELSE()
  set(TARGET_ARCH $ENV{TARGET_ARCH})
ENDIF()

IF(TARGET_ARCH STREQUAL "armhf")
  set(JDK_PATH_ARCH arm)
ELSEIF(TARGET_ARCH STREQUAL "arm64")
  set(JDK_PATH_ARCH aarch64)
ELSEIF(TARGET_ARCH STREQUAL "amd64")
  set(JDK_PATH_ARCH amd64)
ELSE()
  message(STATUS "Selected architecture is not supported")
  return()
ENDIF()

set(CMAKE_LIBRARY_ARCHITECTURE ${CROSS_TRIPLE_PREFIX})
set(CMAKE_C_COMPILER ${CROSS_TRIPLE_PREFIX}-gcc-${GCC_VERSION})
set(CMAKE_CXX_COMPILER ${CROSS_TRIPLE_PREFIX}-g++-${GCC_VERSION})

set(CMAKE_SYSROOT /opt/root)
set(CMAKE_STAGING_PREFIX /opt/staging)
# We cannot just use overriden JAVA_HOME as cmake then tries to execute java -version
# command. But fails because of foreign arch
set(JAVA_HOME_CROSS ${CMAKE_SYSROOT}/usr/lib/jvm/java-8-openjdk-${TARGET_ARCH})
set(CMAKE_FIND_ROOT_PATH ${CMAKE_STAGING_PREFIX} ${CMAKE_SYSROOT} ${JAVA_HOME_CROSS})
set(CMAKE_FIND_ROOT_PATH_MODE_PROGRAM NEVER)
set(CMAKE_FIND_ROOT_PATH_MODE_LIBRARY ONLY)
set(CMAKE_FIND_ROOT_PATH_MODE_INCLUDE ONLY)
set(CMAKE_FIND_ROOT_PATH_MODE_PACKAGE ONLY)

set(CMAKE_EXE_LINKER_FLAGS "-Wl,-rpath-link=${CMAKE_STAGING_PREFIX}/lib")

# 'arm' for armhf, aarch64 for arm64
set(JAVA_AWT_LIBRARY ${JAVA_HOME_CROSS}/lib/${JDK_PATH_ARCH})
set(JAVA_JVM_LIBRARY ${JAVA_HOME_CROSS}/jre/lib/${JDK_PATH_ARCH}/client)
